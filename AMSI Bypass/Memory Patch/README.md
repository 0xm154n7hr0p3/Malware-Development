
# ğ€ğŒğ’ğˆ ğğ²ğ©ğšğ¬ğ¬: ğ€ğ¦ğ¬ğ¢ ğ¦ğğ¦ğ¨ğ«ğ² ğ©ğšğ­ğœğ¡ğ¢ğ§ğ  ğ®ğ¬ğ¢ğ§ğ  ğğ¨ğ°ğğ«ğ¬ğ¡ğğ¥ğ¥.

The fundamental steps of the bypass vulnerability are as follows:

1-ğ‹ğ¨ğšğ ğ­ğ¡ğ ğšğ¦ğ¬ğ¢.ğğ¥ğ¥, which is automatically loaded when a PowerShell session starts.

2-ğŒğ¨ğğ¢ğŸğ² ğ­ğ¡ğ ğ€ğ¦ğ¬ğ¢ğ’ğœğšğ§ğğ®ğŸğŸğğ«() function to consistently return AMSI_RESULT_CLEAN by injection 0x80070057 into EAX register 

Some of the Obfuscation Techniques that were used:

*ğ„ğ§ğœğ¨ğğğ ğ–ğ¢ğ§32 ğ€ğğˆ ğ‚ğšğ¥ğ¥ğ¬: To bypass static analysis, we first encode the Win32 API calls using Base64 and XOR operations. These encoded calls are then stored as byte sequences. At runtime, we deobfuscate these sequences and execute them dynamically.

*ğ€ğ¬ğ¬ğğ¦ğ›ğ¥ğ² ğˆğ§ğ¬ğ­ğ«ğ®ğœğ­ğ¢ğ¨ğ§ğ¬ ğŸğ¨ğ« ğ„ğ¯ğšğ¬ğ¢ğ¨ğ§: Instead of directly loading the detectable value 0x80070057 into the eax register, we use a series of Assembly instructions to achieve the same result indirectly:

mov eax, 0xb39be546

add eax, 0x3efd2145

sub eax, 0x4342d312

xor eax, 0x2f51332e

ret

ğ•ğ¢ğ«ğ®ğ¬ğ“ğ¨ğ­ğšğ¥ ğ’ğœğšğ§ ğ‘ğğ¬ğ®ğ¥ğ­ğ¬: 2/60
